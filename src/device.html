<script src="/socket.io/socket.io.js"></script>
<script>
var app = {
	connected: false,
	connectCounter: 0,
	modulesToReload: [],

	init: function() {
		// Parse device info from url
		var params = window.location.href.split('?')[1].split('&');
		for (var i = 0; i < params.length; i++) {
			var info = params[i].split('=');
			if (info.length < 2) continue;
			this[info[0]] = decodeURIComponent(info[1]);
		}

		this.socket = io();
		this.socket.on('connect', this.onConnect.bind(this));
		this.socket.on('disconnect', this.onDisconnect.bind(this));
		this.socket.on('command', this.onCommand.bind(this));
		window.onbeforeunload = this.closeSocket.bind(this);
		window.onerror = this.onError.bind(this);
	},

	onError: function(msg, file, line) {
		var idx = file.lastIndexOf('/');
		if (idx > -1) file = file.substr(idx + 1);

		this.socket.emit('errorMsg', file, line, msg);

		this.showErrorDiv();

		game.system.pause();
		return false;
	},

	showErrorDiv: function() {
		if (this.errorDiv) return;

		var errorDiv = document.createElement('div');
		errorDiv.style.backgroundColor = 'rgba(255, 0, 0, 0.25)';
		errorDiv.style.position = 'absolute';
		errorDiv.style.left = '0px';
		errorDiv.style.top = '0px';
		errorDiv.style.zIndex = '999999';
		errorDiv.style.width = '100%';
		errorDiv.style.height = '100%';
		errorDiv.ontouchstart = this.errorDivTouch.bind(this);
		errorDiv.onmousedown = this.errorDivTouch.bind(this);
		document.body.appendChild(errorDiv);
		this.errorDiv = errorDiv;
	},

	hideErrorDiv: function() {
		if (!this.errorDiv) return;
		document.body.removeChild(this.errorDiv);
		this.errorDiv = null;
	},

	errorDivTouch: function(event) {
		event.preventDefault();
		this.reloadGame();
	},

	closeSocket: function() {
		this.socket.close();
	},

	onCommand: function(command, param) {
		if (this[command]) this[command](param);
	},

	onConnect: function() {
		this.connected = true;
		this.socket.emit('register', {
			platform: this.platform,
			model: this.model
		});
		if (this.hadConnection) this.reloadGame();
	},

	onDisconnect: function() {
		this.connected = false;
		this.hadConnection = true;
	},

	exitGame: function() {
		this.closeSocket();
		history.back();
	},

	reloadGame: function() {
		this.closeSocket();
		window.location.reload();
	},

	changeScene: function(scene) {
		scene = scene || game.system.sceneName;

		this.hideErrorDiv();
		
		if (game.assetQueue.length + game.audioQueue.length > 0) {
			var loader = new game.Loader(scene);
			loader.start();
		}
		else {
			game.system.setScene(scene);
		}
	},

	reloadModules: function(modules) {
		game.config.autoStart = false;
		game.ready = this.reloadModule.bind(this);

		for (var i = 0; i < modules.length; i++) {
			this.modulesToReload.push(modules[i]);
		}

		if (this.modulesToReload.length > 0) this.reloadModule();
	},

	modulesLoaded: function() {
		this.changeScene();
	},

	reloadModule: function() {
		var module = this.modulesToReload.pop();
		if (!module) return this.modulesLoaded();

		// Delete module classes
		for (var i = 0; i < game.modules[module].classes.length; i++) {
			var className = game.modules[module].classes[i];
			delete game[className];
		}

		// Delete module
		delete game.modules[module];

		// Load new module script
		var path = 'src/' + module.replace(/\./g, '/') + '.js';
		var script = document.createElement('script');
		script.type = 'text/javascript';
		script.src = path;
		document.getElementsByTagName('head')[0].appendChild(script);

		// TODO remove previous script from head
	}
};

game.module('engine.editor')
.require('engine.debug')
.body(function() {
	game.Debug.inject({
		_setText: function(text) {
			text += ' CONNECTED: ' + app.connected;
			this.super(text);
		}
	});
	// Disable debug start messages
	game.onStart = function() {};
});

var previousConsole = window.console || {};
window.console = {
	log: function(msg) {
		previousConsole.log && previousConsole.log(msg);
		app.socket.emit('console', 'log', msg);
	},

	warn: function(msg) {
		previousConsole.warn && previousConsole.warn(msg);
		app.socket.emit('console', 'warn', msg);
	},

	error: function(msg) {
		previousConsole.error && previousConsole.error(msg);
		app.socket.emit('console', 'error', msg);
	}
};

var currentTouches = {},
    eventName = { touchstart: 'touchstart', touchend: 'touchend' };

if (window.navigator.msPointerEnabled) {
    eventName = { touchstart: 'MSPointerDown', touchend: 'MSPointerUp' };
}

document.addEventListener(eventName.touchstart, function(evt) {
    var touches = evt.touches || [evt],
        touch;
    for(var i = 0, l = touches.length; i < l; i++) {
        touch = touches[i];
        currentTouches[touch.identifier || touch.pointerId] = touch;
    }
}, false);

document.addEventListener(eventName.touchend, function(event) {
    var touchCount = Object.keys(currentTouches).length;
    currentTouches = {};
    if (touchCount === 3) {
        event.preventDefault();
        window.history.back(window.history.length);
    }
    if (touchCount === 4) {
    	event.preventDefault();
    	app.reloadGame();
    }
}, false);

app.init();

</script>
